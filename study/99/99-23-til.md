---
description: 99클럽 코테 스터디 23일차 TIL 입니다.
---

# \[99클럽 코테 스터디 23일차 TIL]  프로그래머스 - 마법의 엘리베이터

## \[level 2] 마법의 엘리베이터 - 148653

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/148653)

#### 문제 설명

마법의 세계에 사는 민수는 아주 높은 탑에 살고 있습니다. 탑이 너무 높아서 걸어 다니기 힘든 민수는 마법의 엘리베이터를 만들었습니다. 마법의 엘리베이터의 버튼은 특별합니다. 마법의 엘리베이터에는 -1, +1, -10, +10, -100, +100 등과 같이 절댓값이 10c (c ≥ 0 인 정수) 형태인 정수들이 적힌 버튼이 있습니다. 마법의 엘리베이터의 버튼을 누르면 현재 층 수에 버튼에 적혀 있는 값을 더한 층으로 이동하게 됩니다. 단, 엘리베이터가 위치해 있는 층과 버튼의 값을 더한 결과가 0보다 작으면 엘리베이터는 움직이지 않습니다. 민수의 세계에서는 0층이 가장 아래층이며 엘리베이터는 현재 민수가 있는 층에 있습니다.

마법의 엘리베이터를 움직이기 위해서 버튼 한 번당 마법의 돌 한 개를 사용하게 됩니다.예를 들어, 16층에 있는 민수가 0층으로 가려면 -1이 적힌 버튼을 6번, -10이 적힌 버튼을 1번 눌러 마법의 돌 7개를 소모하여 0층으로 갈 수 있습니다. 하지만, +1이 적힌 버튼을 4번, -10이 적힌 버튼 2번을 누르면 마법의 돌 6개를 소모하여 0층으로 갈 수 있습니다.

마법의 돌을 아끼기 위해 민수는 항상 최소한의 버튼을 눌러서 이동하려고 합니다. 민수가 어떤 층에서 엘리베이터를 타고 0층으로 내려가는데 필요한 마법의 돌의 최소 개수를 알고 싶습니다. 민수와 마법의 엘리베이터가 있는 층을 나타내는 정수 `storey` 가 주어졌을 때, 0층으로 가기 위해 필요한 마법의 돌의 최소값을 return 하도록 solution 함수를 완성하세요.

***

**제한사항**

* 1 ≤ `storey` ≤ 100,000,000

***

**입출력 예**

| storey | result |
| ------ | ------ |
| 16     | 6      |
| 2554   | 16     |

***

**입출력 예 설명**

**입출력 예 #1**

* 문제 예시와 같습니다.

**입출력 예 #2**

* \-1, +100이 적힌 버튼을 4번, +10이 적힌 버튼을 5번, -1000이 적힌 버튼을 3번 누르면 0층에 도착 할 수 있습니다. 그러므로 16을 return 합니다.

***

## 풀이 코드

```java
class Solution {
    public int solution(int storey) {
        int answer = 0;
        while(storey > 0) {
            int n = storey % 10; // 일의 자리
            storey /= 10; // 일의 자리를 제외한 나머지 값
            
            if (n == 5) {
                if (storey % 10 >= 5) { // 앞자리 수가 5보다 크거나 같은 경우
                    answer += 10 - n;
                    storey++;
                } else {
                    answer += n;
                }
            } else if (n > 5) {
                answer += 10 - n;
                storey++;
            } else {
                answer += n;
            }
        }
        return answer;
    }
}
```

* Time: 0.03 ms
* Memory: 63.9 MB

해당 문제에서 주어지는 민수가 있는 층 변수 `storey` 에 5 가 있을 때 처리 방식을 제대로 구현하지 못해서 계속 틀렸고 질문하기에서 테스트 케이스를 찾고나서야 풀 수 있었다. 일단 풀이를 보면 일의 자리부터 하나씩 뽑아가면서 0층에 도달하기 위한 최소값을 찾는다.

일의 자리 수가 5 보다 크면 아래로 내려가기 위해 -1층을 누르는 것보다 위로 올라갔다가 -10층 버튼으로 한번에 내려오는게 더 적게 버튼을 누른다. 반대로 5보다 작으면 -1층 버튼을 누르는게 더 버튼을 적게 누른다. 결국 아래와 같이 일의 자리의 크기에 따라 버튼을 눌러야 하는 횟수가 정해진다.

* 1층 : -1층
* 2층 : -1층, -1층
* 3층 : -1층, -1층, -1층
* 4층 : -1층, -1층, -1층, -1층
* 5층 : -1층, -1층, -1층, -1층, -1층 또는 +1층, +1층, +1층, +1층, +1층
* 6층 : +1층, +1층, +1층, +1층
* 7층 : +1층, +1층, +1층
* 8층 : +1층, +1층
* 9층 : +1층

여기서 5층의 경우에는 위로 올라가는 것과 아래로 내려가는게 같다고 생각했기 때문에 일의 자리가 5보다 크지 않으면 그 숫자만큼 -1층을 누르는걸로 처리해버렸다. 로직도 깔끔해서 마음에 들었으나 계속 틀렸고 아래의 테스트 케이스를 찾을 수 있었다.

* 민수가 있는 층 : 555층
* \-1층 \* **5번** + -10층 \* **5번** + -100층 \* **5번** => 총 15번 버튼 누름
* \+1층 \* **5번** + +10층 \* **4번** + +100층 \* **4번** + -1000층 \* **1번** -> 총 14번 버튼 누름

위 예시를 보면 층을 다음 자릿수까지 올라가면 다음 자릿수는 그 다음 자릿수까지 갈 때 버튼을 한번 적게 눌러도 된다. 숫자가 2자리일 때까지는 다음 자릿수까지 갔다가 해당 자릿수에서 -100층 버튼 한번 누르는게 한번 적게 누른 것과 상쇄돼서 동일한 버튼 개수를 누르게 되지만 3자리부터는 한번 적게 누른 횟수가 추가되기 때문에 -1000층 버튼 한번 누른 것보다 적게 누른 횟수가 더 많아진다.

***

## 돌아보기

그리디 알고리즘 유형의 문제들은 사람을 희망고문 시킨다. 풀 수 있을 것 같은데 항상 반례를 못 찾아서 틀린다.

### 다음에는

* 미심쩍은 부분을 그냥 넘기지 않기
* 긴 시간 집중할 수 있는 체력 기르기

***

\#99클럽 #코딩테스트준비 #개발자취업 #항해99 #TIL
